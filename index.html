<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Color Catch</title>
  <style>
    :root {
      --bg-1: #0b0f14;
      --bg-2: #111827;
      --panel: rgba(2,6,12,0.55);
      --panel-border: rgba(148,163,184,0.18);
      --text: #e5e7eb;
      --muted: #cbd5e1;
    }

    html, body {
      height: 100%;
      margin: 0;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, #0f172a 0%, #0b1220 35%, #060a12 65%, #03060b 100%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      overflow: hidden;
    }

    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 2;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
      user-select: none;
      pointer-events: none;
      gap: 12px;
      flex-wrap: wrap;
    }

    #hud .group {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
    }

    #hud .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(148,163,184,0.15);
      border: 1px solid rgba(148,163,184,0.25);
      pointer-events: auto;
    }

    .color-chip {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.6);
      box-shadow: 0 0 10px rgba(255,255,255,0.2) inset;
    }

    #game {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      touch-action: none;
      cursor: pointer;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 3;
      pointer-events: none;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 16px;
      padding: 18px 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 60px rgba(0,0,0,0.45);
      text-align: center;
      max-width: 92vw;
      pointer-events: auto;
    }

    .panel h1 {
      margin: 0 0 6px;
      font-size: clamp(20px, 4vw, 28px);
    }

    .panel p {
      margin: 6px 0;
      color: var(--muted);
    }

    .panel kbd {
      background: rgba(148,163,184,0.18);
      border: 1px solid rgba(148,163,184,0.35);
      padding: 2px 6px;
      border-radius: 6px;
      font-weight: 700;
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="hud">
    <div class="group">
      <span class="badge">Score: <span id="score" style="margin-left:6px;">0</span></span>
      <span class="badge">Best: <span id="best" style="margin-left:6px;">0</span></span>
    </div>
    <div class="group">
      <span class="badge">
        Lives:
        <span id="lives" style="margin-left:6px;">❤❤❤</span>
      </span>
      <span class="badge">
        Your color:
        <span id="chip" class="color-chip"></span>
      </span>
    </div>
  </div>

  <canvas id="game"></canvas>

  <div id="startOverlay" class="overlay">
    <div class="panel">
      <h1>Color Catch</h1>
      <p>Catch blocks that match your color. Wrong color loses a life.</p>
      <p><kbd>← →</kbd> or <kbd>A D</kbd> to move · <kbd>Space</kbd> to start/pause</p>
      <p>Mobile: tap or drag to move</p>
      <p style="opacity:.85;margin-top:8px;">Click or press Space to begin</p>
    </div>
  </div>

  <div id="pauseOverlay" class="overlay hidden">
    <div class="panel">
      <h1>Paused</h1>
      <p>Press <kbd>Space</kbd> or click to resume</p>
    </div>
  </div>

  <div id="overOverlay" class="overlay hidden">
    <div class="panel">
      <h1>Game Over</h1>
      <p>Your score: <span id="finalScore">0</span></p>
      <p style="opacity:.85;">Press <kbd>Space</kbd> or click to play again</p>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d', { alpha: true });
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const livesEl = document.getElementById('lives');
      const chipEl = document.getElementById('chip');
      const startOverlay = document.getElementById('startOverlay');
      const pauseOverlay = document.getElementById('pauseOverlay');
      const overOverlay = document.getElementById('overOverlay');
      const finalScoreEl = document.getElementById('finalScore');

      let W = 0, H = 0, dpi = Math.min(2, window.devicePixelRatio || 1);
      function resize() {
        W = canvas.clientWidth;
        H = canvas.clientHeight;
        canvas.width = Math.floor(W * dpi);
        canvas.height = Math.floor(H * dpi);
        ctx.setTransform(dpi, 0, 0, dpi, 0, 0);
      }
      // Size canvas to viewport
      const resizeObserver = new ResizeObserver(resize);
      resizeObserver.observe(document.body);

      // Colors
      const COLORS = ['#ff4757', '#1e90ff', '#2ed573', '#ffa502', '#a66bff'];
      function randColor() { return COLORS[Math.floor(Math.random() * COLORS.length)]; }

      // State
      let running = false;
      let paused = false;
      let over = false;

      let score = 0;
      let best = Number(localStorage.getItem('colorCatchBest') || 0);
      bestEl.textContent = String(best);

      let lives = 3;
      const maxLives = 5;

      const player = {
        w: 90, h: 18,
        x: 0, y: 0,
        vx: 0,
        speed: 520,
        color: randColor()
      };

      const blocks = [];
      let spawnTimer = 0;
      let time = 0;

      // Input
      const keys = new Set();
      let pointerActive = false, pointerX = 0;

      window.addEventListener('keydown', (e) => {
        if (['ArrowLeft','ArrowRight',' ','a','A','d','D'].includes(e.key)) e.preventDefault();
        if (e.key === ' ') togglePauseOrStart();
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.add('left');
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.add('right');
      });
      window.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.delete('left');
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.delete('right');
      });

      function setPointer(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        pointerX = Math.max(0, Math.min(W, x));
      }
      canvas.addEventListener('pointerdown', (e) => {
        setPointer(e);
        pointerActive = true;
        canvas.setPointerCapture(e.pointerId);
        if (!running || paused || over) togglePauseOrStart(true);
      });
      canvas.addEventListener('pointermove', (e) => { if (pointerActive) setPointer(e); });
      canvas.addEventListener('pointerup', () => { pointerActive = false; });
      canvas.addEventListener('pointercancel', () => { pointerActive = false; });
      startOverlay.addEventListener('click', () => togglePauseOrStart(true));
      pauseOverlay.addEventListener('click', () => togglePauseOrStart(true));
      overOverlay.addEventListener('click', () => togglePauseOrStart(true));

      function togglePauseOrStart(forceStart = false) {
        if (!running || over || forceStart) {
          startGame();
          return;
        }
        paused = !paused;
        pauseOverlay.classList.toggle('hidden', !paused);
      }

      // Game control
      function resetGame() {
        score = 0;
        lives = 3;
        time = 0;
        spawnTimer = 0;
        blocks.length = 0;
        player.color = randColor();
        chipEl.style.background = player.color;
        player.x = (W - player.w) / 2;
        player.y = H - player.h - 24;
        updateHUD();
      }

      function startGame() {
        over = false;
        paused = false;
        running = true;
        startOverlay.classList.add('hidden');
        pauseOverlay.classList.add('hidden');
        overOverlay.classList.add('hidden');
        lastT = performance.now();
        if (blocks.length === 0) resetGame();
        requestAnimationFrame(loop);
      }

      function gameOver() {
        over = true;
        running = false;
        finalScoreEl.textContent = String(score);
        if (score > best) {
          best = score;
          localStorage.setItem('colorCatchBest', String(best));
          bestEl.textContent = String(best);
        }
        overOverlay.classList.remove('hidden');
      }

      // HUD
      function updateHUD() {
        scoreEl.textContent = String(score);
        livesEl.textContent = '❤'.repeat(lives) + '♡'.repeat(Math.max(0, maxLives - lives));
      }

      // Spawning
      function spawnBlock() {
        const size = 28 + Math.random() * 18;
        const x = Math.random() * (W - size);
        const y = -size - 4;
        const speedBase = 140 + time * 4; // ramps over time
        const vy = speedBase + Math.random() * 120;

        // 12% rainbow bonus
        const isRainbow = Math.random() < 0.12;
        const color = isRainbow ? 'rainbow' : randColor();

        blocks.push({ x, y, size, vy, color, rot: Math.random() * Math.PI, spin: (Math.random() - 0.5) * 1.5 });
      }

      // Drawing
      function drawBackground() {
        // Subtle vignette
        const g = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.2, W/2, H/2, Math.max(W,H)*0.8);
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(1, 'rgba(0,0,0,0.25)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);
      }

      function drawPlayer() {
        // Neon plate
        ctx.save();
        ctx.translate(player.x + player.w/2, player.y + player.h/2);
        const grad = ctx.createLinearGradient(-player.w/2, 0, player.w/2, 0);
        grad.addColorStop(0, 'rgba(255,255,255,0.9)');
        grad.addColorStop(1, player.color);
        ctx.fillStyle = grad;
        ctx.shadowColor = player.color;
        ctx.shadowBlur = 16;
        roundRect(ctx, -player.w/2, -player.h/2, player.w, player.h, 8, true, false);
        ctx.shadowBlur = 0;
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        roundRect(ctx, -player.w/2, -player.h/2, player.w, player.h, 8, false, true);
        ctx.restore();
      }

      function drawBlock(b) {
        ctx.save();
        ctx.translate(b.x + b.size/2, b.y + b.size/2);
        ctx.rotate(b.rot);
        if (b.color === 'rainbow') {
          const rg = ctx.createLinearGradient(-b.size/2, 0, b.size/2, 0);
          ['#ff0059','#ff7a00','#ffd400','#00e05a','#00c8ff','#6a00ff','#ff0059'].forEach((c,i,arr)=>{
            rg.addColorStop(i/(arr.length-1), c);
          });
          ctx.fillStyle = rg;
          ctx.strokeStyle = 'rgba(255,255,255,0.7)';
          ctx.lineWidth = 2;
          roundRect(ctx, -b.size/2, -b.size/2, b.size, b.size, 6, true, true);
          // Glow pass
          ctx.shadowColor = '#ffffff';
          ctx.shadowBlur = 14;
          roundRect(ctx, -b.size/2, -b.size/2, b.size, b.size, 6, true, false);
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = b.color;
          ctx.strokeStyle = 'rgba(255,255,255,0.6)';
          ctx.lineWidth = 2;
          roundRect(ctx, -b.size/2, -b.size/2, b.size, b.size, 6, true, true);
        }
        ctx.restore();
      }

      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      // Loop
      let lastT = 0;
      function loop(t) {
        if (!running) return;
        const dt = Math.min(0.033, (t - lastT) / 1000 || 0);
        lastT = t;

        if (!paused) {
          time += dt;
          spawnTimer += dt;
          const spawnInterval = clamp(0.95 - time * 0.02, 0.2, 0.95);
          if (spawnTimer >= spawnInterval) {
            spawnTimer = 0;
            spawnBlock();
            if (time > 25 && Math.random() < 0.3) spawnBlock();
          }

          // Input movement
          let dir = 0;
          if (keys.has('left')) dir -= 1;
          if (keys.has('right')) dir += 1;

          if (pointerActive) {
            // Lerp towards pointer X
            const target = clamp(pointerX - player.w/2, 0, W - player.w);
            player.x += (target - player.x) * Math.min(1, 12 * dt);
          } else {
            player.x += dir * player.speed * dt;
          }
          player.x = clamp(player.x, 0, W - player.w);
          player.y = H - player.h - 24;

          // Update blocks
          for (let i = blocks.length - 1; i >= 0; i--) {
            const b = blocks[i];
            b.y += b.vy * dt;
            b.rot += b.spin * dt;

            // Collision with player (AABB)
            if (rectsOverlap(player.x, player.y, player.w, player.h, b.x, b.y, b.size, b.size)) {
              // Catch logic
              if (b.color === 'rainbow') {
                // Bonus: +3 points, and +1 life if not full
                score += 3;
                if (lives < maxLives) lives += 1;
              } else if (colorsEqual(b.color, player.color)) {
                score += 1;
              } else {
                lives -= 1;
                if (lives <= 0) {
                  updateHUD();
                  gameOver();
                  break;
                }
              }
              blocks.splice(i, 1);
              updateHUD();
              continue;
            }

            // Remove if off-screen
            if (b.y > H + b.size) {
              blocks.splice(i, 1);
            }
          }
        }

        // Render
        ctx.clearRect(0, 0, W, H);
        drawBackground();
        blocks.forEach(drawBlock);
        drawPlayer();

        if (running) requestAnimationFrame(loop);
      }

      // Utils
      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
      function rectsOverlap(x1,y1,w1,h1,x2,y2,w2,h2) {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
      }
      function colorsEqual(a,b){ return a.toLowerCase() === b.toLowerCase(); }

      // Initialize
      function init() {
        resize();
        resetGame();
      }
      init();

      // Pause on tab hide
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && running && !over) {
          paused = true;
          pauseOverlay.classList.remove('hidden');
        }
      });
    })();
  </script>
</body>
</html>
